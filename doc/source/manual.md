# Mili Python Manual

Mili Python is a python module that allows users to interact with Mili databases. The module contains several submodules that faciliate various operations on these databases. The main submodules that currently exists are:

- reader
- adjacency
- append_states

The `reader` module allows users to read a mili database and query the data inside such as results and mesh geometry. This module also supports some derived calculations and the ability to overwrite state variables in the database.

The `adjacency` module supports a few adjacency queries on a given Mili database such as getting all the elements within a radius of another element or getting all elements associated with a given node.

The `append_states` module provides an interface for adding additional states and state data to existing Mili databases.

This manual documents the features of the mili-python modules and provides examples of how to use it.

# Overview of Mili Databases

It can be useful to have a general understanding of Mili databases so a brief description and some useful information is provided here:

Mili databases consist of two main file types. There is the "A" file and 0 or more state files. The "A" file defines information about the mesh, elements, state variables, etc. that exist in the database. It is commonly referred to as the "A" file because the names of these files end with an "A" (bar10.pltA or dblpltA). The state file(s) store the results for the state variables in the Mili database. These files have the same basename as the associated "A" file but end with a numeric sequence to differentiate them (bar10.plt00, bar10.plt01, ...).

Mili databases commonly take one of two forms: Serial (combined) or Parallel (Uncombined).
- Serial databases are composed of a single "A" file and the associated state files.
- Parallel databases have many "A" files each storing a portion of the simulation. These are generated by the simulation codes running in parallel and each processor writing out its own Mili database.

# Table of Contents

- [Installation](#installation)
- [Importing the Reader Module](#importing-the-reader-module)
- [Opening a Database](#opening-a-database)
- [Querying Results](#querying-results)
- [Derived Variables](#derived-variables)
- [Modifying Results](#modifying-results)
- [Appending States with mili-append](#appending-states-with-mili-append)
- [Adjacency Queries](#adjacency-queries)
- [MiliDatabase Member Functions](#milidatabase-class-member-functions)
    - [all_labels_of_material](#all_labels_of_material)
    - [class_names](#class_names)
    - [class_labels_of_material](#class_labels_of_material)
    - [classes_of_state_variable](#classes_of_state_variable)
    - [classes_of_derived_variable](#classes_of_derived_variable)
    - [components_of_vector_svar](#components_of_vector_svar)
    - [containing_state_variables_of_class](#containing_state_variables_of_class)
    - [connectivity](#connectivity)
    - [derived_variables_of_class](#derived_variables_of_class)
    - [element_sets](#element_sets)
    - [integration_points](#integration_points)
    - [int_points_of_state_variable](#int_points_of_state_variable)
    - [labels](#labels)
    - [material_classes](#material_classes)
    - [material_numbers](#material_numbers)
    - [materials](#materials)
    - [materials_of_class_name](#materials_of_class_name)
    - [mesh_dimensions](#mesh_dimensions)
    - [nodes_of_elems](#nodes_of_elems)
    - [nodes_of_material](#nodes_of_material)
    - [nodes](#nodes)
    - [parts_of_class_name](#parts_of_class_name)
    - [queriable_svars](#queriable_svars)
    - [state_variables_of_class](#state_variables_of_class)
    - [state_maps](#state_maps)
    - [supported_derived_variables](#supported_derived_variables)
    - [times](#times)
- [License](#license)

# Installation

There are currently two methods of installing the mili-python module. The recommeded method is installing from the WCI Nexus Mirror (LLNL specific). However, if this does not work, users may also install from source using the Git or GitHub repositories.

## From the WCI Nexus Mirror
```
module load python/3.10.8
python -m venv <venv_name>
source <venv_name>/bin/activate
pip install --upgrade pip
pip install --upgrade --no-cache mili
```
- Make sure you're using python > 3.7:
- Create a python virtual environment to install packages into locally:
- Activate the environment:
- Upgrade pip (numpy > 1.20.0 will fail to build with the base RZ pip):
- Install the mili python package into the local venv from the WCI Nexus Mirror:

> **Note:** Using `--find-links=<url>` will pull dependencies from the WCI Nexus Mirror, which should contain sufficient requirements to install mili-python and should be available on OCF and SCF.
> **Note:** Using `--upgrade` will upgrade any already-installed copies of the mili module in the venv.

If you want to install the packages into your ~/.local/ python cache so the module is usable with the system python install, try instead not creating and activating a virtual environment and instead (untested and may not work):
```
module load python/3.10.8
python -m pip install --upgrade pip --user
python -m pip install --upgrade --user --no-cache mili
```

## From Gitlab Repository
```bash
git clone ssh://git@rzgitlab.llnl.gov:7999/mdg/mili/mili-python.git
cd mili-python
python3 -m venv venv-mili-python
source venv-mili-python/bin/activate
pip3 install --upgrade pip
pip3 install -e .
```

## From GitHub Repository
```bash
git clone https://github.com/mdg-graphics/mili-python.git
cd mili-python
python3 -m venv venv-mili-python
source venv-mili-python/bin/activate
pip3 install --upgrade pip
pip3 install -e .
```

# Importing the reader module

Before opening a Mili database, users will need to import the `reader` module as shown below:

```python
from mili import reader
```

# Opening a Database

You can open a Mili database using the function `open_database`.

```python
def open_database(base : Union[str,bytes,os.PathLike],
                  procs: Optional[List[int]] = [],
                  suppress_parallel: Optional[bool] = False,
                  experimental: Optional[bool] = False,
                  merge_results: Optional[bool] = False,
                  **kwargs ):
  """Open a database for querying. This opens the database metadata files and does additional processing to optimize query
  construction and execution. Don't use this to perform database verification, instead prefer AFileIO.parse_database().

  Args:
   base (Union[str,bytes,os.PathLike]): the base filename of the mili database (e.g. for 'pltA', just 'plt', for parallel
                                        databases like 'dblplt00A', also exclude the rank-digits, giving 'dblplt')
   procs (Optional[List[int]]) : optionally a list of process-files to open in parallel, default is all
   suppress_parallel (Optional[Bool]) : optionally return a serial database reader object if possible (for serial databases).
                                        Note: if the database is parallel, suppress_parallel==True will return a reader that will
                                        query each processes database files in series.
   experimental (Optional[Bool]) : optional developer-only argument to try experimental parallel features
   merge_results (Optional[Bool]): Merge parallel results into the serial format.
  """
```

This function will return a `MiliDatabase` object. The `MiliDatabase` class provides an api for interacting with Mili databases.

> **NOTE**: The `MiliDatabase` class supports the context management protocol and can be used with the `with` statement as a context manager.

> **NOTE**: While users can set the argument `merge_results` to False, that is not recommended.

## Examples
```python
from mili import reader
from mili.milidatabase import MiliDatabase

# To open a serial database
db: MiliDatabase = reader.open_database('path-to-mili-files.plt')

# To open a parallel database in serial
db: MiliDatabase = reader.open_database('path-to-mili-files.plt', suppress_parallel=True)

# To open a parallel database in parallel
db: MiliDatabase = reader.open_database('path-to-mili-files.plt')
```

> **WARNING**: If on an LLNL system, you do not want to open a parallel database in parallel on a login node. This uses a lot of resources and will negatively impact machine performance for other users.

# Querying Results
Querying results from mili database can be done using the `query` function:
```python
  def query( self,
             svar_names : Union[List[str],str],
             class_sname : str,
             material : Optional[Union[str,int]] = None,
             labels : Optional[Union[List[int],int]] = None,
             states : Optional[Union[List[int],int]] = None,
             ips : Optional[Union[List[int],int]] = None,
             write_data : Optional[Mapping[int, Mapping[str, Mapping[str, npt.ArrayLike]]]] = None,
             as_dataframe: bool = False,
             **kwargs ):
    '''
    Query the database for svars, returning data for the specified parameters, optionally writing data to the database.
    The parameters passed to query can be identical across a parallel invocation of query, since each individual
      database query object will filter only for the subset of the query it has available.

    : param svar_names : short names for state variables being queried
    : param class_sname : mesh class name being queried
    : param material : optional sname or material number to select labels from
    : param labels : optional labels to query data about, filtered by material if material if material is supplied, default is all
    : param states: optional state numbers from which to query data, default is all
    : param ips : optional for svars with array or vec_array aggregation query just these components, default is all available
    : param write_data : optional the format of this is identical to the query result, so if you want to write data, query it first to retrieve the object/format,
                   then modify the values desired, then query again with the modified result in this param
    : param as_dataframe : optional. If True the result is returned as a Pandas DataFrame
```

Here are a few example queries:
```python
from mili import reader
db = reader.open_database( 'base_filename', suppress_parallel = True )

# Query the result nodpos[ux] for the node element class
# Because labels is None, this will return the result for all nodes.
# Because states is None, this will return the result for all states in the database.
result = db.query('nodpos[ux]', 'node')

# Query the result sx for the brick element class.
# Only query the label 228 at state number 10
result = db.query( 'sx', 'brick', labels = [228], states = [10])

# Query the result refrcx for the node element class
# Get this result for element labels 6,7,8 at states 1,3,3
result = db.mili.query( 'refrcx', 'node', labels = [6,7,8], states = [1,2,3])

# Query the result eps for the shell element class.
# Get the result for label 1 at state number 2.
# This result has multiple integration points, Only get integration point 1.
result = db.query( 'eps', 'shell', labels = [1], states = [2], ips = [1])

# Query the result sx for the brick element class
# Get result for all brick elements that are material number 2
# Only get state 37
result = db.query('sx', 'brick', material = 2, states = 37 )

# Query the result sx for the brick element class
# Get result for all brick elements that have material name 'es_12'
# Only get state 37
result = db.query('sx', 'brick', material = 'es_12', states = 37 )
```

## Understanding the results:

Lets take a look at how the returned results are formatted using the query below.
```python
result = db.query('nodpos[ux]', 'node')
```

The return format for the above examples is:
```python
result = {
    'nodpos[ux]' : {
        'layout' : {
            'states'  : <numpy_array_of_states>
            'labels' : <numpy_array_of_labels>
        }
        'data': <numpy_multidim_array_of_data>
    },
}
```

## Getting data out of the result dictionary

The data array is indexed with tuples of the form `(state_index, label_index, scalar_index)`. To be clear the `state_index` and `label_index` are the indices of the state and label in the list of states and list of labels passed to query function call, which is why these are also returned in the 'layout' data since those query arguments are optional. Thus to find the indices for state `T` and node label `N`, we need to:
```python
sidx = np.where(T == result['nodpos[ux]']['layout']['states'])
nidx = np.where(N == result['noppos[ux]']['layout']['labels'])
# the above return size-1 numpy arrays (assuming they succeed)
N_data_at_T = result['nodpos[ux]']['data'][sidx[0], nidx[0],:]
```
**Note**: if you only need data for a single node or for a single state, format the query so only that data is returned rather than querying large amounts of data and indexing into it as above.

## Result Dictionary Utility Functions

There are some additional functions that users will find helpful in reorganizing the data into an easier to use format. One of these is the `results_by_element` function.

### The `results_by_element` function

The `results_by_element` function extracts all the data from a result dictionary (For both serial and parallel database) and reorganizes the data into a new dictionary with the form `<variable-name> : { <element-id> : <numpy_array_of_data> }`.

```python
from mili.reader import results_by_element

result = db.query("stress", "brick")
element_data = results_by_element( result )

# OR

element_data = results_by_element( db.query("stress", "brick") )

stress_brick_101 = element_data['stress'][101]
# [[ STATE 1: sx, sy, sz, sxy, syz, szx ],
#  [ STATE 2: sx, sy, sz, sxy, syz, szx ]
#  [ STATE 3: sx, sy, sz, sxy, syz, szx ]
#  ... ]

# NOTE: State 0 is not the first state in the problem, but the first state
#       that you queried. That may be the first state in the problem or a different
#       state depending on the arguments you passed to the query
stress_brick_20_state_0 = element_data['stress'][101][0]

# Integration Point Data

# The shell elements have integration points 1 and 2 for stress
element_data = results_by_element( db.query("sy", "shell") )

sy_shell_1 = element_data['sy'][1]
# [[ STATE 1: sy_int_point1, sy_int_point2 ],
#  [ STATE 2: sy_int_point1, sy_int_point2 ]
#  [ STATE 3: sy_int_point1, sy_int_point2 ]
#  ... ]
```

### Pandas DataFrames

Optionally the results of the query method can be returned as a Pandas DataFrame. If the keyword argument `as_dataframe` is set to `True` then the result dictionary will store the data for each state variable as a DataFrame.

```python
result = reader.combine( db.query( 'sx', 'brick', as_dataframe=True ) )

"""
results will have the format:
{
  <svar-name> : <dataframe>,
  <svar-name> : <dataframe>,
  ...
}
"""

sx_df = result['sx']
# sx_df.columns are the labels
# sx_df.index are the state numbers

sx_brick_12_state_44 = sx_df[12][44]
```

> **WARNING**: Querying vector state variables, such as `stress` or `strain` with `as_dataframe=True` can take a very long time, especially in parallel. It is not recommended that you query vector state variables as dataframes. Vector state variable data is stored in 3 dimensional array (num_states by num_labels by num_components) and Pandas DataFrames are not very efficient with 3 dimensional data. There are significant overheads associated with converting the data to a DataFrame as well as performing the data serialization that is required when using mili-python in parallel.

> **NOTE**: The DataFrames can be converted back to the dictionary format if necessary (such as when overwriting data) using the `dataframe_to_result_dictionary` function. Existing result dictionaries can be converted to dataframes using the `result_dictionary_to_dataframe` function.

---

> **NOTE**: Mixed-data subrecords (subrecords containing more than 1 datatype (e.g. mixed double/float, int/double, etc)) are functional but have received less testing and performance evaluation, so some performance degredation is expected when querying variables from these subrecords.

# Derived Variables

mili-python supports many derived variables that can be queried using the `query` method. To see the derived variables that are supported in mili-python use the function `supported_derived_variables` as show below:

```python
print( db.supported_derived_variables() )
```

> **NOTE:** Not all of these variables are necessarily able to be calculated for every database. This list contains all the derived variables that mili-python can calculate if the required primal variables exist for your specific database.

To determine the derived variables that can be calculated for your specific database you can use the functions `derived_variables_of_class` or `classes_of_derived_variable`.  The function `derived_variables_of_class` takes an element class
name as the argument and returns a list of the derived variables that can be calculated for the class. The function `classes_of_derived_variable` takes a derived variable name as the argument and returns a list of the classes for which the derived variable can be calculated.

```python
classes_eff_stress = db.classes_of_derived_variable("eff_stress")
# ["brick", "beam", "shell"]

nodal_derived_variables = db.derived_variables_of_class("node")
# ["disp_x", "disp_y", ...]
```

> **NOTE:** These functions do not guarantee that the derived variable can be calculated for **ALL** elements of the specified element class. They are checking that all the primal variables required to calculate the specific derived variable exist within the database for a given class (It does not check which specific elements of that class the primals exist for).

Querying these derived variables works the same as querying any primal variable. The following are several examples of queries for derived results.

```python
result = db.query('disp_x', 'node')

# Query the pressure for the brick element class.
result = db.query( 'pressure', 'brick', labels = [228], states = [10])

# Query the result disp_mag for the node element class
result = db.mili.query( 'disp_mag', 'node', labels = [6,7,8], states = [1,2,3])

# Query the 1st principle stress for the shell element class.
result = db.query( 'prin_stress1', 'shell', labels = [1], states = [2], ips = [1])
```

> **NOTE**: When calculating rate-based results, numerical difference methods are used to approximate the time derivatives of primal variables. These results include nodal velocity, nodal acceleration, and effective plastic strain rate. There are a few limitations and assumptions for these results:
>- The accuracy of the results is highly dependent on the size of the time step. Smaller time steps provide more accurate results.
>- The calculations assume that the time step is the same on each side of the calculation time ( t^(n-1) and t^(n+1) ).  Significant differences in dt will result in more error.
>- Results for the first and last states use forward and backward difference methods, which are less accurate than the central difference method used for the other states.  The exception is that nodal velocity uses backward difference for all states (except state 1), which is consistent with the griz calculation.  The nodal velocity at state 1 is set to zero.
>- When possible, have the analysis code output primal variables for rates instead of calculating derived variables.  They will almost always be more accurate, and will never be less accurate.

# Modifying Results

```python
# For a Serial Database
db = reader.open_database( 'base_filename', suppress_parallel = True )
nodpos_ux = db.query( 'nodpos[ux]', 'node' )
# modify nodpos_ux
nodpos_ux = db.query( 'nodpos[ux]', 'node', write_data = nodpos_ux )

# For a Parallel Database
db = reader.open_database( 'base_filename', suppress_parallel = True )
nodpos_ux = db.query( 'nodpos[ux]', 'node' )
# This merges all the individual processor result dictionaries into a single dictionary
nodpos_ux = reader.combine(nodpos_ux)
# modify nodpos_ux
nodpos_ux = db.query( 'nodpos[ux]', 'node', write_data = nodpos_ux )

# When using the results_by_element function
nodpos_ux = db.query( 'nodpos[ux]', 'node' )
nodpos_by_element = results_by_element( nodpos_ux )
# Modify nodpos_by_element
writeable_nodpos = writeable_from_results_by_element(nodpos_ux, nodpos_by_element)
nodpos_ux = db.query( 'nodpos[ux]', 'node', write_data = writeable_nodpos )
```

Will write modified data back to the database. The `write_data` must have the same format as the result data for an identical query. In practice it is best to simply process a query, modify the results, and then submit the same query supplying the modified results as the `write_data` argument.

> **Note:** minimal enforcement/checking of the `write_data` structure is currently done and malformed `write_data` *could* possibly (unlikely) cause database corruption, use at your own discretion. Create backups, test on smaller databases first, etc. A python expection is the most likely outcome here, but caution is best.

# Appending States with `mili-append`

`mili-append` is a script that provides users with a framework for adding additional states to a database. New states and data can be appended to the end of an existing database or added to a new database (A copy of the existing database with just the new states added). Users can specify the states and data to be appended by creating the dictionary `append_states_spec` in a separate python file. This file is then the input to the tool. A complete list of available fields in the `append_states_spec` dictionary as well as an example of defining the dictionary is shown below:

Available fields in `append_states_spec`:

| Field                |Type         |Description                                              |Required                        |
|----------------------|-------------|---------------------------------------------------------|--------------------------------|
|database_basename     |str          |The name of the input database.                          |Always                          |
|output_type           |List[str]    |List of outputs. Options include: "mili".                |Always                          |
|output_mode           |str          |"write" or "append".                                     |Always                          |
|output_basename       |str          |The name of the new database if output_mode is "write".  |When `output_mode` is "write"   |
|states                |int          |The number of states to add.                             |Always                          |
|state_times           |List[float]  |The new state times to append to the database.           |If `time_inc` is not provided   |
|time_inc              |float        |The increment for each new state to add.                 |If `state_times` is not provided|
|state_variables       |dict         |The state variable data to append                        |Always                          |
|limit_states_per_file |int          |Limit the number of states in generated state files      |False                           |
|limit_bytes_per_file  |int          |Limit the number of bytes in generated state files       |False                           |

The format of the `state_variables` dictionary is:
```python
"state_variables": {

  "class-name-1": {
    "state-variable-1": {
      # Labels is a list of integers
      "labels": [1,2,3,...],
      # int_point specifies the integration point you are writing out data for (Only needed for results with multiple integration points)
      # If this value is omitted for a state variable that has multiple integration points, then "data" must have values for all integration points
      # that exist
      "int_point": 2,
      # Data is a 2d-array that is num_states_to_append by (num_elems * values_per_element)
      # Data can also be a 1d-array of length num_states_to_append * num_elems * values_per_element
      "data": [
        [1.0, 2.0, 3.0, ...],
        [1.0, 2.0, 3.0, ...],
        ...
      ]
    },
    "state-variable-2": {
      "labels": [10, 11, 12],
      "data": [
        [1.0, 2.0, 3.0, ...],
        [1.0, 2.0, 3.0, ...],
        ...
      ]
    }
  },

  "class-name-2": {
    # ...
  }
  # ...
}
```

An example of the `append_states_spec` and how to run the tool:

```python
# example_input.py
import numpy as np
from mili.reader import open_database

"""
The code below demonstrates one of the main advantages of having this defined in a python file
that the tool can then import. It allows users to write their own code to read in/setup the new
data that will be appended. This means that users can get data from multiple different sources or
file formats as long as they format it correctly. Below are examples of reading in the data from a txt
file using numpy, hard coding your own values, and reading in data from another mili database.
"""
stress_data = np.loadtxt("example_stress_data.txt", comments="#", dtype=object)
brick_labels = stress_data[:,1]
brick_data = np.array( [stress_data[:,3]] )

node_labels = [1,2,3,4,5]
node_data = [ [1.0, 2.0, 3.0, 4.0, 5.0] ]

different_database = open_database("some-other-database-name")
shell_results = different_database.query("ey", "shell", states=[55], labels=[1,2,3], ips=[1])
shell_labels = shell_results['ey']['layout']['labels']
shell_data = np.reshape( shell_result['ey']['data'], (1,len(shell_labels)) )

# The name of the dictionary must be append_states_spec
append_states_spec = {
  "database_basename": "dblplt",    # The name of the database we are appending data to.
  "output_type": ["mili"],          # Output is a mili database. "mili" is currently the only option but we will likely support for outputs in the future
  "output_mode": "write",           # Write out a new database with 0 states and append the new states/data to it.
  "output_basename": "new_dblplt",  # The new database to write. Required because output_mode is "write"

  "states": 1,        # We want to append 1 states to the database
  "time_inc": 0.001,  # New time will increment 0.001 from the last state of the input database

  # The state variable data to append to the database
  "state_variables": {
    "node": {
      "evec_dx": {
        "labels": node_labels,
        "data": node_data
      }
    },
    "brick": {
      "sx": {
        "labels": brick_labels,
        "data": brick_data
      }
    },
    "shell": {
      "ey": {
        "labels": shell_labels,
        "data": shell_data
      }
    }
  }
}
```

## Usage

`mili-append` is a script that is installed with mili-python. To run with `example_input.py` shown above:

> `mili-append -i example_input.py`

**NOTE**: This assumes you have installed mili locally or in an active virtual environment.

## Using the Append States Tool in a Script

It is also possible to use the append states tool from within a script as shown below. The dictionary passed to the `AppendStatesTool` object must still have the same format as `append_states_spec`.

```python
from mili.append_states import AppendStatesTool

append_states_spec = {
  # ...
}

append_tool = AppendStatesTool(append_states_spec)
append_tool.write_states()
```

# Adjacency Queries

The mili-python reader provides some support for querying element adjacencies through the `AdjacencyMapping` wrapper. The current list of supported adjacency queries includes:
- Querying all elements/nodes within a specified radius of a given element using the function `mesh_entities_within_radius`.
- Querying all elements/nodes within a specified radius of a given 3d coordinate using the function `mesh_entities_near_coordinate`.
- Querying all elements associated with a set of specific nodes using the `elems_of_nodes` function.
- Querying the nearest node to a 3d coordinate using the `nearest_node` function.
- Querying the nearest element to a 3d coordinate using the `nearest_element` function.
- Querying the neighboring elements for a given element using the `neighbor_elements` function.

The function `mesh_entities_within_radius` computes the centroid of the element you have specified using the nodal coordinates for that element at the specified state. The reader then gathers all nodes within the specified radius of that centroid and returns all elements that are associated with those nodes. This function also takes the optional arguement `material` that limits the search to specific material name(s) or number(s).

```python
from mili import adjacency
adj = adjacency.AdjacencyMapping(db)

# Gathers the elements within a radius of 0.30 length units from shell 6 at state 1
adjacent_elements = adj.mesh_entities_within_radius("shell", 6, 1, 0.30, material=None)
adjacent_elements = adj.mesh_entities_within_radius("shell", 6, 1, 0.30, material=2)
adjacent_elements = adj.mesh_entities_within_radius("shell", 6, 1, 0.30, material=[1,2])

"""
The format of the returned dictionary is shown below:

adjacent_elements = {
    "shell": [3,4,5,6,9,11],
    "beam": [5,6,37,42],
    "cseg": [2,3,5,6,8,9],
    "node": [1,2,3,4,5,6,7,12,13,14,15,16],
}
"""
```

The function `mesh_entities_near_coordinate` gathers all nodes within the specified radius of the given 3d coordinate and returns all elements that are associated with those nodes. This function also takes the optional arguement `material` that limits the search to specific material name(s) or number(s).

```python
from mili import adjacency
adj = adjacency.AdjacencyMapping(db)

# Gathers the elements within a radius of 0.30 length units from the given coordinate at state 1
adjacent_elements = adj.mesh_entities_near_coordinate([0.21874996, 0.8163861, 2.], 1, 0.3, material=None)
adjacent_elements = adj.mesh_entities_near_coordinate([0.21874996, 0.8163861, 2.], 1, 0.3, material=2)
adjacent_elements = adj.mesh_entities_near_coordinate([0.21874996, 0.8163861, 2.], 1, 0.3, material=[3,4])

"""
The format of the returned dictionary is shown below:

adjacent_elements = {
    "shell": [3,4,5,6,9,11],
    "beam": [5,6,37,42],
    "cseg": [2,3,5,6,8,9],
    "node": [1,2,3,4,5,6,7,12,13,14,15,16],
}
"""
```

The function `elems_of_nodes` gathers all elements associated with a set of nodes. This function also takes the optional arguement `material` that limits the search to specific material names or numbers.

```python
from mili import adjacency

adj = adjacency.AdjacencyMapping(db)

elems = adj.elems_of_nodes(120)
# or
elems = adj.elems_of_nodes([1,2,3])
```

The dictionary returned by `elems_of_nodes` has the same format as that returned by `mesh_entities_within_radius`

The function `nearest_node` finds the closest node to a given 3d coordinate at a specified time step.

```python
from mili import adjacency
adj = adjacency.AdjacencyMapping(db)

# Get the closest node and its distance from the point (0.0, 0.0, 0.0) at state 1.
nearest_node, distance = adj.nearest_node( [0.0, 0.0, 0.0], 1)
```

The function `nearest_element` finds the element whose centroid is closest to a given 3d coordinate at a specified time step.
```python
from mili import adjacency
adj = adjacency.AdjacencyMapping(db)

# Get the closest element (class name and label) and its distance from the point (0.0, 0.0, 0.0) at state 1.
class_name, label, distance = adj.nearest_element( [0.0, 0.0, 0.0], 1)
```

The function `neighbor_elements` finds all elements that neighbor the specified element. A neighbor element is defined as any element that shares a node with the specified element. The `neighbor_radius` argument can be used to specify the number of steps out from the element to perform while gathering the neighbor elements. The `material` argument can be used to limit the elements that are returned to specified material names or numbers.
```python
from mili import adjacency
adj = adjacency.AdjacencyMapping(db)

neighbors = adj.neighbor_elements("brick", 1, neighbor_radius=2, material=2)
"""
The format of the returned dictionary is shown below:

neighbors = {
    "brick": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
              11, 12, 13, 14, 15, 16, 17, 18,
              19, 21, 23, 25, 27, 29, 31, 33, 35]
}
"""
```

# MiliDatabase Class member functions

## all_labels_of_material
```python
  def all_labels_of_material( self, mat: Union[str,int] ) -> Dict[str,np.ndarray]:
    """Given a specific material. Find all labels with that material and return their values.

    Args:
      mat (Union[str,int]): The material name or number.

    Returns:
      Dict[str,np.ndarray]: Keys are element class names. Values are numpy arrays of element labels.
    """
```

### Example
```python
lbls = db.all_labels_of_material( 1 )
print(lbls)
"""
{'beam': array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,
       18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
       35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46], dtype=int32)}
"""
```

## class_names
```python
  def class_names(self) -> List[str]:
    """Getter for all class names in the database.

    Returns:
      List[str]: List of element class names in the database.
    """
```

### Example
```python
class_names = db.class_names()
print(class_names)
"""
['glob', 'mat', 'node', 'beam', 'brick', 'shell', 'cseg']
"""
```

## class_labels_of_material
```python
  def class_labels_of_material( self, mat: Union[str,int], class_name: str ) -> np.ndarray:
    """Convert a material name into labels of the specified class (if any).

    Args:
      mat (Union[str,int]): The material name or number.
      class_name (str): The element class name.

    Returns:
      np.ndarray: array of labels of the specified class name and material.
    """
```

### Example
```python
lbls = db.class_labels_of_material( 4, 'cseg' )
print(lbls)
"""
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12])
"""
```

## classes_of_state_variable
```python
  def classes_of_state_variable(self, svar: str) -> List[str]:
    """Get list of element classes for a state variable.

    Args:
      svar (str): The state variable name.

    Returns:
      List[str]: List of element classes the state variable exists for.
    """
```

### Example
```python
classes = db.classes_of_state_variable('sx')
print(classes)
"""
['shell', 'beam', 'brick']
"""
```

## classes_of_derived_variable
```python
  def classes_of_derived_variable(self, var_name: str) -> List[str]:
    """Get the classes for which a derived variable can be calculated.

    Args:
      var_name (str): The derived variable name:

    Returns:
      List[str]: List of element class names for which var_name can be calculated.
    """
```

### Example
```python
classes = db.classes_of_derived_variables("pressure")
print(classes)
# ["brick", "beam", "shell"]
```

## components_of_vector_svar
```python
  def components_of_vector_svar(self, svar: str) -> List[str]:
    """Get a list of component state variables of a vector state variable.

    Args:
      svar (str): The name of a vector state variable.

    Returns:
      List[str]: The components of the vector state variable.
    """
```

### Example
```python
comps = db.components_of_vector_svar("stress")
print(comps)
# ["sx", "sy", "sz", "sxy", "syz", "szx"]
```

## containing_state_variables_of_class
```python
  def containing_state_variables_of_class(self, svar: str, class_name: str) -> List[str]:
    """Get List of state variables that contain the specific state variable + class_name

    Args:
      svar (str): The state variable name.
      class_name (str): The element class name.

    Returns:
      List[str]: List of containing state variables.
    """
```

### Example
```python
containing = db.containing_state_variables_of_class("sx", "brick")
print(containing)
# ["stress"]
```

## connectivity
```python
  def connectivity( self, class_name : Optional[str] = None ) -> Union[Dict[str,np.ndarray],np.ndarray]:
    """Getter for the element connectivity as element LABELS

    Args:
      class_name (str): An element class name. If provided only return connectivty for the specified class.

    Returns:
      Union[Dict[str,np.ndarray],np.ndarray]: If class_name is None the a dictionary containing
        the connectivity for each element class is returned. If class_name is not None, then a numpy array
        is returned containing the connectivity for the specified element class. If the specified element
        class does not exists then None is returned.
    """
```

### Example
```python
conns = db.connectivity()
print(conns.keys())
print(conns['brick'])
"""
['beam', 'brick', 'shell', 'cseg']
array([[ 64,  80,  84,  68,  65,  81,  85,  69],
       [ 80,  96, 100,  84,  81,  97, 101,  85],
       [ 68,  84,  88,  72,  69,  85,  89,  73],
       [ 84, 100, 104,  88,  85, 101, 105,  89],
       [ 72,  88,  92,  76,  73,  89,  93,  77],
       [ 88, 104, 108,  92,  89, 105, 109,  93],
       [ 65,  81,  85,  69,  66,  82,  86,  70],
       [ 81,  97, 101,  85,  82,  98, 102,  86],
       [ 69,  85,  89,  73,  70,  86,  90,  74],
       [ 85, 101, 105,  89,  86, 102, 106,  90],
       [ 73,  89,  93,  77,  74,  90,  94,  78],
       [ 89, 105, 109,  93,  90, 106, 110,  94],
       [ 66,  82,  86,  70,  67,  83,  87,  71],
       [ 82,  98, 102,  86,  83,  99, 103,  87],
       [ 70,  86,  90,  74,  71,  87,  91,  75],
       [ 86, 102, 106,  90,  87, 103, 107,  91],
       [ 74,  90,  94,  78,  75,  91,  95,  79],
       [ 90, 106, 110,  94,  91, 107, 111,  95],
       [ 96, 112, 116, 100,  97, 113, 117, 101],
       [112, 128, 132, 116, 113, 129, 133, 117],
       [100, 116, 120, 104, 101, 117, 121, 105],
       [116, 132, 136, 120, 117, 133, 137, 121],
       [104, 120, 124, 108, 105, 121, 125, 109],
       [120, 136, 140, 124, 121, 137, 141, 125],
       [ 97, 113, 117, 101,  98, 114, 118, 102],
       [113, 129, 133, 117, 114, 130, 134, 118],
       [101, 117, 121, 105, 102, 118, 122, 106],
       [117, 133, 137, 121, 118, 134, 138, 122],
       [105, 121, 125, 109, 106, 122, 126, 110],
       [121, 137, 141, 125, 122, 138, 142, 126],
       [ 98, 114, 118, 102,  99, 115, 119, 103],
       [114, 130, 134, 118, 115, 131, 135, 119],
       [102, 118, 122, 106, 103, 119, 123, 107],
       [118, 134, 138, 122, 119, 135, 139, 123],
       [106, 122, 126, 110, 107, 123, 127, 111],
       [122, 138, 142, 126, 123, 139, 143, 127]], dtype=int32)
"""
```

## derived_variables_of_class
```python
  def derived_variables_of_class(self, class_name: str) -> List[str]:
    """Get the derived variables that can be calculated for the specified class.

    Args:
      class_name (str): The element class name.

    Returns:
      List[str]: List of derived variables that can be calculated for the specified class.
    """
```

## element_sets
```python
  def element_sets(self) -> Dict[str,List[int]]:
    """Getter for the element sets.

    Returns:
      Dict[str,List[int]]: Keys are element set names, values are list of integers
    """
```

> **NOTE**: Users shouldn't need to use the `element_sets` method. The same information can be retrieved more easily using the `integration_points` method.


## integration_points
```python
  def integration_points(self) -> Dict[str,List[int]]:
    """Get the available integration points for each material.

    Returns:
      Dict[str,List[int]]: Keys are material numbers, values are a list of integration points.
    """
```

### Example
```python
ipts = db.integration_points()
# ipts = {'1': [1,2,3,4], '3': [1,2]}
```

## int_points_of_state_variable
```python
  def int_points_of_state_variable(self, svar_name: str, class_name: str) -> np.ndarray:
    """Get the available integration points for a state variable + class_name.

    Args:
      svar_name (str): The state variable name.
      class_name (str): The element class name.

    Returns:
      np.ndarray: Array of integration points.
    """
```

### Example
```python
ipts = db.int_points_of_state_variable("sx", "beam")
print(ipts)
# [1, 2, 3, 4]
```

## labels
```python
  def labels(self, class_name: Optional[str] = None) -> Union[Dict[str,np.ndarray],np.ndarray]:
    """Getter for the element labels.

    Args:
      class_name (Optional[str]): If provided, only return labels for specifid element class.

    Returns:
      Union[Dict[str,np.ndarray],np.ndarray]: If class_name is None the a dictionary containing
        the labels for each element class is returned. If class_name is not None, then a numpy array
        is returned containing the labels for the specified element class.
    """
```

### Example
```python
labels = db.labels('shell')
print(labels)
"""
array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12], dtype=int32)
"""
```

## material_classes
```python
  def material_classes(self, mat: Union[str,int]) -> List[str]:
    """Get list of classes of a specified material.

    Args:
      mat (Union[str,int]): A material name or number.

    Returns:
      List[str]: List of element classes associated with the material.
    """
```

### Example
```python
classes = db.material_classes(1)
# ["brick"]
```

## material_numbers
```python
  def material_numbers(self) -> np.ndarray:
    """Get a List of material numbers in the database.

    Returns:
      np.ndarray: A numpy array of the material numbers.
    """
```

### Example
```python
mat_nums = db.material_numbers()
print(mat_nums)
"""
[1, 2, 3, 4, 5]
"""
```

## materials
```python
  def materials(self) -> Dict[str,List[int]]:
    """Get materials dictionary from the database.

    Returns:
      Dict[str,List[int]]: Keys are the material names, Values are a list of material numbers.
    """
```

## materials_of_class_name
```python
  def materials_of_class_name( self, class_name: str ) -> np.ndarray:
    """Get List of materials for all elements of a given class name.

    Args:
      class_name (str): The element class name.

    Returns:
      np.ndarray: array of material numbers for each element of the class name.
    """
```

### Example
```python
mats = db.materials_of_class_name( 'cseg' )
print(mats)
"""
array([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], dtype=int32)
"""
```

## mesh_dimensions
```python
  def mesh_dimensions(self) -> int:
    """Getter for Mesh Dimensions.

    Returns:
      int: Either 2 or 3 for the number of dimensions.
    """
```

### Example
```python
dims = db.mesh_dimensions()
# 3
```

## nodes_of_elems
```python
  def nodes_of_elems(self, class_sname: str, elem_labels: Union[int,List[int]]) -> Tuple[np.ndarray,np.ndarray]:
    """Find nodes associated with elements by label.

    Args:
      class_sname (str): The element class name.
      elem_labels (List[int]): List of element labels.

    Returns:
      Tuple[np.ndarray,np.ndarray]: (The nodal connectivity, The element labels)
    """
```

### Example
```python
nodes = db.nodes_of_elems( 'brick', [1,2] )
"""
array([
        [ 65,  81,  85,  69,  66,  82,  86,  70],
        [ 81,  97, 101,  85,  82,  98, 102,  86]
      ], dtype=int32),
array([[1], [2]], dtype=int32)
"""
```

## nodes_of_material
```python
  def nodes_of_material(self, mat: Union[str,int] ) -> np.ndarray:
    """Find nodes associated with a material number.

    Args:
      mat (Union[str,int]): The material name or number.

    Returns:
      numpy.array: A list of all nodes associated with the material number.
    """
```

### Example
```python
nodes = db.nodes_of_material( 5 )
"""
array([ 65,  69,  73,  77,  81,  85,  89,  93,  97, 101, 105, 109, 113,
        117, 121, 125, 129, 133, 137, 141], dtype=int32)
"""
```

## nodes
```python
  def nodes(self) -> np.ndarray:
    """Getter for initial nodal coordinates.

    Returns:
      np.ndarray: A numpy array (num_nodes by mesh_dimensions) containing the initial coordinates for each node.
    """
```

### Example
```python
nodes = db.nodes()
print(nodes)
"""
array([[ 1.0000000e+00,  0.0000000e+00,  0.0000000e+00],
       [ 9.6592581e-01,  2.5881904e-01,  1.0000000e+01],
       [ 8.6602539e-01,  5.0000000e-01,  0.0000000e+00],
       [ 7.0710677e-01,  7.0710677e-01,  1.0000000e+01],
       [ 4.9999997e-01,  8.6602545e-01,  0.0000000e+00],
       [ 2.5881907e-01,  9.6592581e-01,  1.0000000e+01],
       [-4.3711388e-08,  1.0000000e+00,  0.0000000e+00],
       [ 1.0100000e+00,  0.0000000e+00,  1.0000000e+00],
       [ 8.7468565e-01,  5.0500000e-01,  1.0000000e+00]], dtype=float32)
"""
```

## parts_of_class_name
```python
  def parts_of_class_name( self, class_name: str ) -> np.ndarray:
    """Get List of part numbers for all elements of a given class name.

    Args:
      class_name (str): The element class name.

    Returns:
      np.ndarray: array of part numbers for each element of the class name.
    """
```

## queriable_svars
```python
  def queriable_svars(self, vector_only = False, show_ips = False) -> List[str]:
    """Get a list of state variable names that can be queried.

    Args:
      vector_only (bool, default=False): Return on vector state variables.
      show_ips (bool, default=False): Show the available integration points.

    Returns:
      List[str]: A list of state variable names that can be queried.
    """
```

## state_variables_of_class
```python
  def state_variables_of_class(self, class_name: str) -> List[str]:
    """Get list of primal state variables for a given element class.

    Args:
      class_name (str): The element class name.

    Returns:
      List[str]: A list of primal state variables that can be queried for the specified element class.
    """
```

## state_maps
```python
  def state_maps(self) -> List[StateMap]:
    """Getter for internal list of StateMaps.

    Returns:
      List[StateMap]: A list of StateMap objects.
    """
```

## supported_derived_variables
```python
  def supported_derived_variables(self) -> List[str]:
    """Get the derived variables that mili-python currently supports.

    Returns:
      List[str]: A List of derived variable names that can be calculated by mili-python.
    """
```

## times
```python
  def times( self, states : Optional[Union[List[int],int]] = None ) -> np.ndarray:
    """Get the times for each state in the database.

    Args:
      states (Optional[Union[List[int],int]]): If provided, only return the times for the
        specified state numbers.

    Returns:
      np.ndarray: numpy array of times.
    """
```

### Example
```python
times = db.times()
print(times)
"""
array([0.00000000e+00, 9.99999975e-06, 1.99999995e-05, 2.99999992e-05,
       3.99999990e-05, 4.99999987e-05, 5.99999985e-05, 7.00000019e-05,
       7.99999980e-05, 9.00000014e-05, 9.99999975e-05, 1.10000001e-04,
       1.19999997e-04, 1.30000000e-04, 1.40000004e-04, 1.50000007e-04,
       1.59999996e-04, 1.69999999e-04, 1.80000003e-04, 1.90000006e-04,
       1.99999995e-04, 2.09999998e-04, 2.20000002e-04, 2.30000005e-04,
       2.39999994e-04, 2.50000012e-04, 2.60000001e-04, 2.69999990e-04,
       2.80000007e-04, 2.89999996e-04, 3.00000014e-04, 3.10000003e-04,
       3.19999992e-04, 3.30000010e-04, 3.39999999e-04, 3.49999988e-04,
       3.60000005e-04, 3.69999994e-04, 3.80000012e-04, 3.90000001e-04,
       3.99999990e-04, 4.10000008e-04, 4.19999997e-04, 4.29999985e-04,
       4.40000003e-04, 4.49999992e-04, 4.60000010e-04, 4.69999999e-04,
       4.79999988e-04, 4.90000006e-04, 5.00000024e-04, 5.09999983e-04,
       5.20000001e-04, 5.30000019e-04, 5.39999979e-04, 5.49999997e-04,
       5.60000015e-04, 5.69999975e-04, 5.79999993e-04, 5.90000011e-04,
       6.00000028e-04, 6.09999988e-04, 6.20000006e-04, 6.30000024e-04,
       6.39999984e-04, 6.50000002e-04, 6.60000020e-04, 6.69999979e-04,
       6.79999997e-04, 6.90000015e-04, 6.99999975e-04, 7.09999993e-04,
       7.20000011e-04, 7.30000029e-04, 7.39999989e-04, 7.50000007e-04,
       7.60000024e-04, 7.69999984e-04, 7.80000002e-04, 7.90000020e-04,
       7.99999980e-04, 8.09999998e-04, 8.20000016e-04, 8.29999975e-04,
       8.39999993e-04, 8.50000011e-04, 8.59999971e-04, 8.69999989e-04,
       8.80000007e-04, 8.90000025e-04, 8.99999985e-04, 9.10000002e-04,
       9.20000020e-04, 9.29999980e-04, 9.39999998e-04, 9.50000016e-04,
       9.59999976e-04, 9.69999994e-04, 9.80000012e-04, 9.89999971e-04,
       1.00000005e-03])
"""
```

# License

Mili Python Reader is distributed under the terms of both the MIT license.

All new contributions must be made under both the MIT license.

See [LICENSE-MIT](https://github.com/mdg/mili-python/LICENSE)

SPDX-License-Identifier: (Apache-2.0 OR MIT)

LLNL-CODE-838121
